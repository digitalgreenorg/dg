define(function(require) {
    'use strict';
    
    var EventManager = require('framework/EventManager');
    var DataModel = require('app/libs/DataModel');
    var Util = require('framework/Util');
    var jQuery = require('jquery');

    var DataFeed = EventManager.extend({

        /**
         * Object to store all configuration variables
         * @type {Object}
         */
        _config: undefined,

        /**
         * Object to store all state related variables
         * @type {Object}
         */
        _state: undefined,

        /**
         * DataModel object for storing/managing data
         * @type {DataModel}
         */
        _dataModel: undefined,

        /**
         * DataFeed Constructor
         * @return {void}
         */
        constructor: function(feedURL) {
            this._config = {};
            // this is being set here to avoid having to pass it into the _initConfig() function,
            // thus affecting all inheriting children to require it in the function signature
            this._config.feedURL = feedURL;
            this._initConfig();

            this._boundFunctions = {};
            this._initEvents();

            this._state = {};
            this._initState();

            this._dataModel = new DataModel();
        },

        /**
         * Function to organize config init
         * @return {void}
         */
        _initConfig: function() {
            var config = this._config;
            config.maxFailures = 5;
            config.fetchDelay = 0;
        },

        /**
         * Function to organize event binding functionality
         * @return {void}
         */
        _initEvents: function(params) {},

        /**
         * Function to organize state init
         * @return {void}
         */
        _initState: function(params) {
            var state = this._state;

            state.failureCounter = 0;
            state.inputParams = {};
            state.fetchTimeout = null;
        },

        /**
         * Setter for the feed url
         * @param {String} feedURL The new URL
         * @return {DataFeed} this
         */
        setFeedURL: function(feedURL) {
            this._config.feedURL = feedURL;
        },

        /**
         * A public interface function to begin the fetch process.
         * If any functionality is intended other than a query being made to the provided URL,
         * this function is intended to be overridden.
         * @param {Object} overrideData Additional data to append/override the data automatically generated by this class with
         * @param {Function} customCallback A custom callback to run once data is received
         * @return {void}
         */
        fetch: function(overrideData, customCallback) {

            var state = this._state;

            if (state.fetchTimeout) {
                clearTimeout(state.fetchTimeout);
                state.fetchTimeout = null;
            }

            var fetchDelay = this._config.fetchDelay;

            if (fetchDelay) {
                state.fetchTimeout = setTimeout(this._fetch.bind(this, overrideData, customCallback), fetchDelay);
            } else {
                this._fetch(overrideData, customCallback);
            }
        },

        /**
         * Returns data for a feed.
         * This is a function stub and is intended to be overridden by extending classes
         * @return {Object} Feed data
         */
        getFeedData: function() {
            throw new Error('DataFeed.getFeedData() not implemented.');
        },

        addInputParam: function(name, required, defaultValue, triggerOnChangeEvent, cachesToClearOnChange) {

            if (name == undefined) {
                throw new Error('DataFeed.addInputParam(): parameter "name" required but not provided');
            }

            if (cachesToClearOnChange && !Util.Array.isArray(cachesToClearOnChange)) {
                cachesToClearOnChange = [cachesToClearOnChange];
            }

            this._state.inputParams[name] = {
                value: undefined,
                required: !!required,
                defaultValue: defaultValue,
                onChange: {
                    triggerEvent: !!triggerOnChangeEvent,
                    clearCaches: cachesToClearOnChange || []
                }
            };

            return this;
        },

        addInputParamCacheClear: function(name, cachesToClearOnChange) {
            if (name == undefined) {
                throw new Error('DataFeed.addInputParamCacheClear(): parameter "name" required but not provided');
            }

            var state = this._state;
            if (state.inputParams[name] == undefined) {
                throw new Error('DataFeed.addInputParamCacheClear(): an input parameter with the name "' + name + '" has not yet been added');
            }

            var cacheArray = state.inputParams[name].onChange.clearCaches;

            if (cachesToClearOnChange && !Util.Array.isArray(cachesToClearOnChange)) {
                cachesToClearOnChange = [cachesToClearOnChange];
            }

            var i = 0;
            var len = cachesToClearOnChange.length;
            for (; i < len; i++) {
                cacheArray.push(cachesToClearOnChange[i]);
            }

        },

        setInputParam: function(name, value, suppressOnChangeEvent) {
            var inputParamData = this._state.inputParams[name];

            if (inputParamData == undefined) {
                throw new Error('DataFeed.setInputParam(): unable to find input param data for input parameter "' + name + '"; did you add it with addInputParam()?');
            }

            if (inputParamData.value == value) {
                return false;
            }

            inputParamData.value = value;

            if (suppressOnChangeEvent != true) {
                this._inputParamChanged(name);
            }

            return true;
        },

        _inputParamChanged: function(name) {
            var inputParamData = this._state.inputParams[name];

            var cachesToClear = inputParamData.onChange.clearCaches;
            var cachesToClearLength = cachesToClear.length;
            if (cachesToClearLength) {
                var i = 0;
                for (; i < cachesToClearLength; i++) {
                    cachesToClear[i].clear();
                }
            }

            if (inputParamData.onChange.triggerEvent) {
                this.trigger('inputParamChanged', name, inputParamData.value);
            }
        },

        getInputParam: function(name) {

            var inputParamData = this._state.inputParams[name];

            if (inputParamData.required && inputParamData.value == undefined) {
                if (inputParamData.defaultValue == undefined) {
                    throw new Error('DataFeed._getAjaxInputParamData(): parameter "' + name + '" is required, no value was supplied, and no default value was set');
                }

                return inputParamData.defaultValue;
            }

            return inputParamData.value;
        },

        _fetch: function(overrideData, customCallback) {

            var state = this._state;

            state.fetchTimeout = null;

            // TODO: test this
            if (state.failureCounter > this._config.maxFailures) {
                state.failureCounter = 0;
                this.trigger('fetchAborted');
                return;
            }

            var feedURL = this._config.feedURL;
            
            
            var inputParamData = this._getAjaxInputParamData();

            Util.Object.extend(inputParamData, overrideData);
            $.ajax({
                type: 'GET',
                dataType: 'json',
                url: feedURL,
                data: inputParamData
            })
            .error(this._onFetchError.bind(this))
            .done(this._onDataReceived.bind(this), customCallback);
        },

        _getAjaxInputParamData: function() {
            var data = {};

            var inputParams = this._state.inputParams;
            var name;
            for (name in inputParams) {
                // var inputParamData = inputParams[name];

                var value = this.getInputParam(name);
                if (value == undefined) {
                    continue;
                }

                data[name] = value;
            }

            return data;
        },

        /**
         * This function is called upon an AJAX fetch error
         * @return {void}
         */
        _onFetchError: function() {
            this._state.failureCounter++;
        },

        /**
         * This function is called once data is retrieved after a fetch request.
         * @param  {mixed} data Mixed data format determined by the result of the fetched data feed
         * @return {void}
         */
        _onDataReceived: function(unprocessedData) {
            this._beforeProcessData(unprocessedData);
            var processedData = this._processData(unprocessedData);
            this._afterProcessData(processedData);
        },

        /**
         * This function is optionally called prior to processing data
         * This is a function stub and is intended to be overridden by extending classes if desired.
         * @return {void}
         */
        _beforeProcessData: function(unprocessedData) {},

        /**
         * This function is called once data is received for processing.
         * This is a function stub and is intended to be overridden by extending classes.
         * @param  {mixed} data Mixed data format determined by the result of the fetched data feed
         * @return {void}
         */
        _processData: function(unprocessedData) {
            throw new Error('DataFeed._processData() not implemented.');
        },

        /**
         * This function is optionally called after processing data
         * @return {void}
         */
        _afterProcessData: function(processedData) {
            this.trigger('dataProcessed', processedData);
        },

        /**
         * DataFeed destroy
         * @return {void}
         */
        destroy: function() {
            this.base();
        }

    });

    return DataFeed;

});