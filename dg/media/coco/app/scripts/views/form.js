// Responsible for preparing form - for both Add and Edit, converting form to json, cleaning json, denormalising json and then triggering "save_clicked" event.
// Supports 2 buttons - first button does the above mentioned tasks from converting form to json to triggering "save_clicked" event.
// seond button - sends "button2_clicked" directly. 
// Used by Upload.js and form_controller.js. Both listen to the save_clicked and button2_clicked events to process the json generated by form
define([
    'jquery',
    'underscore',
    'layoutmanager',
    'form_field_validator',
    'syphon',
    'views/notification',
    'indexeddb_backbone_config',
    'configs',
    'offline_utils',
    'denormalize',
    'indexeddb-backbone',
    'chosen',
    'date_picker',
    'time_picker'
], function(jquery, underscore, layoutmanager, pass, pass, notifs_view, indexeddb, all_configs, Offline, Denormalizer) {


    var ShowAddEditFormView = Backbone.Layout.extend({

        events: {
            'click #button2': 'button2_clicked',
            // used in inline form
            'click #add_rows': 'append_new_inlines'
        },
        template: '#form_template',
        options_inner_template: _.template($('#options_template')
            .html()),

        //would be called when render is called       
        serialize: function() {
            // send the following info to template
            // already contains the names of the buttons
            var s_passed = this.options.serialize;
            // HTML for form 
            s_passed["form_template"] = this.form_template;
            // whether its an inline form
            s_passed["inline"] = (this.inline) ? true : false;
            // name of the entity bieng added/edited
            s_passed["entity_name"] = this.entity_name;
            return s_passed;
        },

        
        // Identifies the action of this form - add/ edit_id/ edit_json  
//         Sets the result on the view object 
//         this.edit_case_id, this.edit_case_json, this.edit_case
        identify_form_action: function(params) {
            // There are two ways in which edit is true - when the ID is given, and the second is when a json is given(LIMIT: can be add too if json is missing id?).
            this.edit_case = false;
            this.edit_id = null;
            if (params.model_json) {
                // edit_case_upload
                this.edit_case_json = true; 
                this.model_json = params.model_json;
                this.edit_case = true;
                this.edit_id = this.model_json.id;
            } else if (params.model_id) {
                this.edit_case_id = true;
                this.edit_case = true;
                this.edit_id = params.model_id;
            }
        },

        
        // Refactor possible
//         Reads entity_config and sets basic properties on view object for easy access
        read_form_config: function(params) {
            this.entity_name = params.entity_name;
            this.entity_config = all_configs[this.entity_name];
            //default locations - 
            this.foreign_entities = this.entity_config.foreign_entities;
            this.inline = this.entity_config.inline;
            this.bulk = this.entity_config.bulk;
            if (this.edit_case) {
                this.form_template = $('#' + this.entity_config.edit_template_name).html();
                if (this.entity_config.edit) {
                    this.foreign_entities = this.entity_config.edit.foreign_entities;
                    this.inline = this.entity_config.edit.inline;
                    this.bulk = this.entity_config.edit.bulk;
                }
            } else {
                this.form_template = $('#' + this.entity_config.add_template_name).html();
                if (this.entity_config.add) {
                    this.foreign_entities = this.entity_config.add.foreign_entities;
                    this.inline = this.entity_config.add.inline;
                    this.bulk = this.entity_config.add.bulk;
                }
            }
        },

        // Relies on view object's context 
        // Gets foreign entities, create their offline collection to be fetched in afterRender
        // Sets up datastructures to setup in-form change events
        // Shamelessly polluting the view object
        setup_foreign_elements: function() {
            //stores the foreign entities' collections
            this.f_colls = []; 
            //stores the index of an entity to access its collection in f_colls            
            this.f_index = []; 
            //stores the dependency mapping between form elements
            this.source_dependents_map = {}; 
            //stores the mapping between foreign element and their entity
            this.element_entity_map = {}; 
            //stores whether a foreign element has been rendered
            this.foreign_elements_rendered = {}; 
            //stores the number of sources for a dependent element
            this.num_sources = {}; 
            //create a collection for each distinct entity, put them in this.f_colls, remem their index in f_colls using f_index
            for (f_entity in this.foreign_entities) {
                var f_collection = Offline.create_b_collection(f_entity, {
                    comparator: function(model) {
                        return model.get(all_configs[this.storeName].sort_field).toLowerCase();
                    }
                });
                this.f_index.push(f_entity);
                this.f_colls.push(f_collection);
                //create entity_map, dependency map, foreign_elements_rendered, for each foreign element
                for (var element in this.foreign_entities[f_entity]) {
                    //created mapping of element - entity
                    this.element_entity_map[element] = f_entity;
                    this.foreign_elements_rendered[element] = false;
                    // creating source - dependency mapping to be used for in-form events
                    var dependency = this.foreign_entities[f_entity][element]["dependency"];
                    if (dependency)
                        this.num_sources[element] = dependency.length;
                    else
                        this.num_sources[element] = 0;
                    if (dependency) {
                        var f_ens = this.foreign_entities;
                        var that = this;
                        $.each(dependency, function(index, dep) {
                            var source_elm = dep.source_form_element;
                            if (source_elm in that.source_dependents_map)
                                that.source_dependents_map[source_elm].push(element);
                            else {
                                that.source_dependents_map[source_elm] = [];
                                that.source_dependents_map[source_elm].push(element);
                            }
                        });
                        console.log("source_dependents_map = " + JSON.stringify(this.source_dependents_map));
                    }

                }
            }
        },

        /*
        params = {
            serialiaze:{
                //name of first button, not shown if ==""
                button1: "...",
                //name of sec button, not shown if ==""
                button2: "..."
            },
            //name of entity to be added/edited
            entity_name:,
            //id of model if edit case
            model_id:,
            //json of model to be shown in edit form - used when json!= json(model_id)
            model_json:,
        }
        */
        initialize: function(params) {
            console.log("ADD/EDIT: params to add/edit view: ");
            console.log(params);
            this.final_json = null;
            _.bindAll(this);

            //sets this.edit_case, and  this.edit_case_id, or this.edit_case_json
            this.identify_form_action(params);

            //read entity_config and sets main properties on view object for easy access
            this.read_form_config(params);

            //reads this.foreign_entities and setsup the collections, source_dependents_map
            this.setup_foreign_elements();
        },

        afterRender: function() {
            var that = this;

            //no foreign element has been rendered yet so disabling all - they get enabled as and when they get rendered
            this.disable_foreign_elements();

            //start in-form change events
            this.start_change_events();

            //fetch all foreign collections and render them when all are fetched
            this.fetch_and_render_foreign_entities();

            //if edit case - fill form with the model
            if (this.edit_case)
                this.render_edit_model();

            //if inline case - render inlines
            if (this.inline)
                this.render_inlines();

            // call validator on the form
            this.initiate_form_field_validation();

            this.initiate_form_widgets();
        },

        //fetches all foreign collections and renders them when all are fetched
        fetch_and_render_foreign_entities: function() {
            var for_entities_fetch_dfds = []
            for (var i = 0; i < this.f_colls.length; i++) {
                console.log("fetching f coll");
                var f_dfd = this.f_colls[i].fetch();
                for_entities_fetch_dfds.push(f_dfd);
            }
            // wait till all foreign collections are fetched and then render the non-dependent foreign elements - the dependent foreign elements gets rendered through in-form events
            $.when.apply($, for_entities_fetch_dfds)
                .done(this.render_non_dep_for_elements)
                .fail(function() {
                    //TODO: handle error callback
                    alert("Atleast one foreign entity could not be fetched!");
                })
        },

        //fill non-dependent foreign elements - dependent gets filled on change events
        render_non_dep_for_elements: function() {
            console.log("Rendering non dependent f elements");
            _.each(this.element_entity_map, function(entity, element) {
                if (!this.foreign_entities[entity][element]["dependency"])
                    this.render_foreign_element(element, this.get_collection_of_element(element).toArray());
            }, this);
        },

        // fetch edit object and render it into form
        render_edit_model: function() {
            var that = this;
            // if this is edit_Case_json case (used by UPLOAD ) - we have the json
            if (this.edit_case_json) {
                // normalise json to put into form
                this.normalize_json(this.model_json);
                // put into form
                this.fill_form();
            } else if (this.edit_case_id) {
                // fetch edit object
                Offline.fetch_object(this.entity_config.entity_name, "id", this.edit_id)
                    .done(function(model) {
                        console.log("EDIT: edit model fetched");
                        that.model_json = model.toJSON();
                        // normalise json to put into form
                        that.normalize_json(that.model_json);
                        // put into form
                        that.fill_form();
                    })
                    .fail(function() {
                        // edit object could not be fetched from offline db
                        //TODO: error handling
                        console.log("ERROR: EDIT: Edit model could not be fetched!");
                        alert("ERROR: EDIT: Edit model could not be fetched!");
                    });
            }
        },

        //disable dropdowns of all foreign elements - they would be enabled as and when they get populated
        disable_foreign_elements: function() {
            for (f_entity in this.foreign_entities) {
                for (element in this.foreign_entities[f_entity]) {
                    if (!this.foreign_entities[f_entity][element].expanded) {
                        this.$('[name=' + element + ']').prop("disabled", true);
                    }
                }
            }
        },

        //render header, empty inlines if add case, fetch and render related inlines if edit case
        render_inlines: function() {
            var that = this;
            this.$('#inline_header').html($('#' + this.inline.header).html());
            //if add case put in empty inlines
            if (!this.edit_case)
                this.append_new_inlines(this.inline.default_num_rows);
            else if (this.edit_case_id) {
                console.log("FORM:EDIT: Fteching inline collection");
                // fetch inline entity's whole collection! can be improved
                Offline.fetch_collection(this.inline.entity)
                    .done(function(collection) {
                        // id-json dictionary of inline models - later used to extend the modified inlines
                        that.inl_models_dict = {};
                        // filter inline collection to get only the ones related to the parent object
                        var inl_models = collection.filter(function(model) {
                            if (model.get(that.inline.joining_attribute.inline_attribute).id == that.edit_id) {
                                that.inl_models_dict[model.get("id")] = model.toJSON();
                                return true
                            }
                            return false;
                        });
                        console.log(inl_models);
                        // render the inlines into the form
                        that.fill_inlines(inl_models);
                    })
                    .fail(function() {
                        console.log("ERROR: EDIT: Inline collection could not be fetched!");
                    });
            }
            //not showing the inlines in case of edit_case_json
        },

        // fills the inline objects in their templates and puts them into form
        fill_inlines: function(model_array) {
            console.log("Filling inlines");
            var that = this;
            var inline_t = _.template($('#' + this.inline.template).html());

            $.each(model_array, function(index, model) {
                var tr = inline_t({
                    index: index
                });
                var filled_tr = that.fill_form_elements($(tr), model.toJSON());
                $(filled_tr).find(':input').removeClass("donotvalidate");
                that.$('#inline_body').append(filled_tr);
                $(filled_tr).on('change', that.switch_validation_for_inlines);
            });
        },

        // appends new empty inlines into form
        append_new_inlines: function(num_rows) {
            // compile the template of inline
            var inline_t = _.template($('#' + this.inline.template).html());
            if (typeof(num_rows) != "number")
                num_rows = this.inline.add_row;
            var start_index = get_index_to_start_from();
            // append the new inlines
            for (var i = start_index; i < start_index + num_rows; i++) {
                var tr = $(inline_t({
                    index: i
                }));
                this.$('#inline_body').append(tr);
                // switch validation on/off based on whether the inline is empty or not
                tr.on('change', this.switch_validation_for_inlines);
            }

            // get last index of already existing inlines
            function get_index_to_start_from() {
                var all_present_inlines = this.$('#inline_body tr').not(".form_error");
                if (!all_present_inlines.length)
                    return 0
                var max_index = $(_.last(all_present_inlines)).attr("index");
                return parseInt(max_index) + 1;
            }
        },

        // to prevent validation of empty inline rows
        switch_validation_for_inlines: function(ev) {
            //get the changed row
            var elem = ev.delegateTarget;
            var empty = true;
            $(elem).find(':input').each(function() {
                if ($(this).val())
                    empty = false;
            });
            if (!empty) {
                // if row is not emoty - turn on validation
                $(elem).find(':input').each(function() {
                    $(this).removeClass("donotvalidate");
                });
            } else {
                // if row is empty - turn off validation
                $(elem).find(':input').each(function() {
                    $(this).addClass("donotvalidate");
                });
            }
        },

        //takes a jquery object containgg form elements and a json. Fills all elements with the corrsponding value in json
        fill_form_elements: function(container, o_json) {
            container.attr("model_id", o_json.id);
            container.find(':input').each(function() {
                if (!$(this).attr('name'))
                    return;
                var attr_name = $(this).attr("name").replace(new RegExp("[0-9]", "g"), "");
                switch (this.type) {
                    case 'password':
                    case 'select-multiple':
                    case 'select-one':
                    case 'text':
                    case 'textarea':
                        $(this).val(o_json[attr_name]);
                        break;
                    case 'checkbox':
                    case 'radio':
                        this.checked = o_json[attr_name];
                }
            });
            return container;
        },

        // start listening to in-form events
        start_change_events: function() {
            for (element in this.source_dependents_map) {
                console.log("creating changeevent for - " + element);
                // put change-event listeners on source elements
                this.$('[name=' + element + ']').change(this.render_dep_for_elements);
            }
        },

        // initiate the jquery validation plugin on the form
        initiate_form_field_validation: function() {
            var that = this;
            // pass the config defined in entity's config
            var validate_obj = $.extend(this.entity_config.form_field_validation, {
                "submitHandler": function() {
                    that.save();
                }
            });
            console.log()
            this.$('form')
                .validate(validate_obj);
        },

        // initiate the dropdown and date, time widgets
        initiate_form_widgets: function() {
            $(".chosen-select").chosen({
                'search_contains': true,
                'width': '100%'
            });


            var eDate = new Date();
            enddate = eDate.getFullYear() + "-" + (eDate.getMonth() + 1) + "-" + eDate.getDate();
            $(".date-picker")
                .datepicker({
                    format: 'yyyy-mm-dd',
                    startDate: '2009-01-01',
                    endDate: enddate,
                }).on('changeDate', function(ev) {
                    $(this).datepicker('hide');
                });

            $(".time-picker")
                .timepicker({
                    minuteStep: 1,
                    defaultTime: false,
                    showMeridian: false
                });
        },

        get_collection_of_element: function(element) {
            var entity = this.element_entity_map[element];
            var index = this.f_index.indexOf(entity);
            return this.f_colls[index];
        },

        get_sources_of_element: function(element) {
            var entity = this.element_entity_map[element];
            return this.foreign_entities[entity][element].dependency;
        },

        get_curr_value_of_element: function(element) {
            return $('[name=' + element + ']').val();
        },

        // render dependent foreign elements - executes when a source element changes
        render_dep_for_elements: function(ev) {
            var source = $(ev.target).attr("name"); //source changed
            console.log("FILLING DEP ENTITIES OF -" + source);
            // Iterate over its dependents
            _.each(this.source_dependents_map[source], function(dep_el) {
                var filtered_models = this.filter_dep_for_element(dep_el);
                this.render_foreign_element(dep_el, filtered_models);
            }, this);
        },

        // Fully Reset the dependent foreign element by looking at all its sources.
        filter_dep_for_element: function(element) {
            //get dependent element's entity's collection - to be filtered
            var dep_collection = this.get_collection_of_element(element);
            // get all sources of this element - to filter by
            var all_sources = this.get_sources_of_element(element);
            //model array to be finally inserted into dom
            var final_models = [];
            var that = this;

            if (!dep_collection.length)
                return [];

            $.each(all_sources, function(index, dep_desc) {
                var dep_attr = dep_desc.dep_attr;
                var source_form_element = dep_desc.source_form_element;
                var filtered_models = [];

                //LIMITS: source can't be an expanded right now, bcoz won't get its value
                var source_curr_value = that.get_curr_value_of_element(source_form_element);
                if (!source_curr_value)
                    return;
                else if (!(source_curr_value instanceof Array)) {
                    //if source is single select - convert its value to array -make it like a multiselect
                    var temp = source_curr_value;
                    source_curr_value = [];
                    source_curr_value.push((temp));
                }

                // many-to-many relation between source and dependent
                if (dep_collection.at(0).get(dep_desc.dep_attr) instanceof Array) {
                    filtered_models = dep_collection.filter(function(model) {
                        var exists = false;
                        //LIMITS: array assumed to contain objects - its an array so possibly other case not possible
                        $.each(model.get(dep_desc.dep_attr), function(index, object) {
                            if ($.inArray(String(object.id), source_curr_value) > -1)
                                exists = true;
                        });
                        return exists;
                    });
                } else {
                    filtered_models = dep_collection.filter(function(model) {
                        var exists = false;
                        var compare = null;
                        if (typeof model.get(dep_desc.dep_attr) == "object")
                            compare = model.get(dep_desc.dep_attr).id;
                        else
                            compare = model.get(dep_desc.dep_attr)

                        if (dep_desc.src_attr && dep_desc.src_attr != "id") {
                            var s_collection = that.get_collection_of_element(source_form_element);
                            var s_model = s_collection.get(parseInt(source_curr_value[0]));
                            if (s_model.get(dep_desc.src_attr) instanceof Array) {
                                //LIMITS: array assumed to contain objects - its an array so possibly other case not possible
                                $.each(s_model.get(dep_desc.src_attr), function(index, src_compare) {
                                    if (compare == src_compare.id)
                                        exists = true;
                                });
                            }
                            return exists;
                        } else {
                            if (!($.inArray(String(compare), source_curr_value) == -1))
                                exists = true;
                            return exists;
                        }
                    });
                }
                final_models = final_models.concat(filtered_models);
            });
            return final_models;
        },

        // filter an array of modal based on a filter defined in configs
        filter_model_array: function(model_array, filter) {
            var filter_attr = filter.attr;
            var filter_value = filter.value;
            filtered = [];
            $.each(model_array, function(index, obj) {
                //LIMIT: assumed to be an object
                if (obj.get(filter_attr).id == filter_value) {
                    filtered.push(obj);
                }
            });
            return filtered;
        },

        // renders a foreign element - dropdown or expanded templates - into the form
        render_foreign_element: function(element, model_array) {
            console.log("FILLING FOREIGN ENTITY - " + element);
            var that = this;
            this.num_sources[element]--;
            var f_entity_desc = this.foreign_entities[this.element_entity_map[element]][element];

            //if any defined, filter the model array before putting into dom
            if (f_entity_desc.filter)
                model_array = this.filter_model_array(model_array, f_entity_desc.filter);

            if (f_entity_desc.expanded) {
                // get the expanded template
                var expanded_template = _.template($('#' + f_entity_desc.expanded.template).html());
                $f_el = this.$('#' + f_entity_desc.expanded.placeholder);
                $f_el.html('');
                //LIMIT: there can be only one expanded foreign element!
                this.expanded = element;

                //Its edit case and edit model is not yet rendered - so render it
                if (this.edit_case && !this.foreign_elements_rendered[element]) {
                    var id_field = "id"
                    if (f_entity_desc.id_field)
                        id_field = f_entity_desc.id_field;
                    var collection = this.get_collection_of_element(element);
                    $.each(this.model_json[element], function(index, f_json) {
                        model = collection.get(f_json[id_field]);
                        if (!model)
                            return;
                        var t_json = model.toJSON();
                        t_json["index"] = index;
                        $.each(f_entity_desc.expanded.extra_fields, function(index, field) {
                            t_json[field] = f_json[field];
                        });
                        console.log(t_json);
                        $f_el.append(expanded_template(t_json));
                    });
                    if (this.num_sources[element] <= 0)
                        this.foreign_elements_rendered[element] = true;
                } else {
                    $.each(model_array, function(index, f_model) {
                        var t_json = f_model.toJSON();
                        t_json["index"] = index;
                        $f_el.append(expanded_template(t_json));
                    });
                }
                this.initiate_form_widgets();
                $('.inline_table').show();
            } else {
                console.log("NOT EXPANDED");
                $f_el = this.$('#' + f_entity_desc.placeholder);
                if ($f_el.is('select[multiple]'))
                    $f_el.html('');
                else
                    $f_el.html(this.options_inner_template({
                        id: "",
                        name: "------------"
                    }));
                $.each(model_array, function (index, f_model) {
                    var f_json = f_model;
                    if (f_model instanceof Backbone.Model)
                        f_json = f_model.toJSON();
                    if (f_json[f_entity_desc.name_field_extra_info]) {
                        var extra_info_group_name = "";
                        var extra_info_person_id = "";
                        var extra_info_father_name = "";
                        if(f_json[f_entity_desc.name_field_father_name] != null){
                            extra_info_father_name = f_json[f_entity_desc.name_field_father_name]
                        }
                        if (f_json[f_entity_desc.name_field_extra_info][f_entity_desc.name_field_group_name] != null) {
                            extra_info_group_name = f_json[f_entity_desc.name_field_extra_info][f_entity_desc.name_field_group_name];
                        }
                        if (f_json[f_entity_desc.name_field_person_id] != null) {
                            extra_info_person_id = f_json[f_entity_desc.name_field_person_id]
                        }
                        $f_el.append(that.options_inner_template({
                            id: parseInt(f_json["id"]),
                            name: f_json[f_entity_desc.name_field] + (extra_info_father_name != "" ? ' (' + extra_info_father_name + ')' : "") + (extra_info_group_name != "" ? ' (' + extra_info_group_name + ')' : "") + (extra_info_person_id !="" ? ' (' + extra_info_person_id + ')' : "")
                        }));
                    }
                    else {
                        $f_el.append(that.options_inner_template({
                            id: parseInt(f_json["id"]),
                            name: f_json[f_entity_desc.name_field]
                        }));
                    }
                });
                $f_el.prop("disabled", false);
                $f_el.trigger("chosen:updated");

                //select the options selected in edit model
                if (this.edit_case && !this.foreign_elements_rendered[element]) {
                    this.$('form [name=' + element + ']').val(this.model_json[element]).change();
                    this.$('form [name=' + element + ']').trigger("chosen:updated");
                    if (this.num_sources[element] <= 0)
                        this.foreign_elements_rendered[element] = true;
                }
            }
        },

        // normalises the json before putting into form
        normalize_json: function(d_json) {
            console.log("FORM: Before Normalised json = " + JSON.stringify(d_json));
            var f_entities = this.foreign_entities;
            for (member in f_entities) {
                for (element in f_entities[member]) {
                    if ((element in d_json) && !(f_entities[member][element].expanded)) {
                        if (d_json[element] instanceof Array) {
                            var el_array = [];
                            $.each(d_json[element], function(index, object) {
                                el_array.push(parseInt(object["id"]));
                            });
                            d_json[element] = el_array;
                        } else {
                            d_json[element] = parseInt(d_json[element]["id"]);
                        }
                    }
                }
            }
            console.log("FORM: Normalised json = " + JSON.stringify(d_json));
            return d_json;
        },

        // Using Backbone.Syphon library to put normalised json into form
        fill_form: function() {
            console.log("FORM: filling form with the model - " + JSON.stringify(this.model_json));
            Backbone.Syphon.deserialize(this, this.model_json);
        },

        // used to disable the save button while save is in progress
        set_submit_button_state: function(state) {
            if (state == "disabled")
                this.$(".action_button").attr("disabled", true);
            else
                this.$(".action_button").button(state);
        },

        //err format - {"mediator": {"__all__": ["Animator with this Name, Gender and Partner already exists."]}}
        // {"form_name": {"element name": [list of errors]}}
        show_errors: function(errors, disable_submit) {
            // used to clear form errors
            if (errors == null) {
                $('.form_error').remove();
                $('.error').removeClass("error");
                return;
            }

            this.set_submit_button_state('reset');
            if (disable_submit)
                this.set_submit_button_state('disabled');

            if (typeof(errors) !== "object")
                errors = $.parseJSON(errors);
            console.log("Showing this error");
            console.log(errors);
            try {
                _.each(errors, function(errors_obj, parent) {
                    var parent_el = this.$('[name=' + parent + ']');
                    $.each(errors_obj, function(error_el_name, error_list) {
                        var error_ul = null;
                        all_li = "<li>" + error_list.join("</li><li>") + "</li>";
                        error_ul = "<tr class='form_error'><td colspan='100%'><ul>" + all_li + "</ul></td></tr>";
                        if (error_el_name == "__all__") {
                            parent_el.before(error_ul); //insert error message
                            parent_el.addClass("error"); //highlight
                        } else {
                            var error_el = parent_el.find('[name=' + error_el_name + ']');
                            error_el
                                .parent('div')
                                .parent('div')
                                .addClass("error"); //highlight
                            error_el.parent().append(error_ul); // insert error message after the element
                        }
                    });
                }, this);
            } catch (err) {
                //if the error object has an unknown format - show it as it is on top of form
                var parent_el = this.$('[name=' + this.entity_name + ']');
                parent_el.before("<div class='form_error'>" + JSON.stringify(errors) + "</div>"); //insert error message
            }

        },

        // TODO: the following 3 methods can be combined into single generic one
        // fetch inline from the form as a list of objects
        parse_inlines: function(raw_json) {
            console.log("FORM: fetching inlines");
            var all_inlines = $('#inline_body tr').not(".form_error");
            raw_json["inlines"] = [];
            var that = this;
            var inline_attrs = [];
            $.each(all_inlines, function(index, inl) {
                var inl_obj = {};
                var ignore = true;
                inl_obj.index = $(inl).attr("index");
                if ($(inl).attr("model_id"))
                    inl_obj.id = parseInt($(inl).attr("model_id"));
                $(inl).find(':input').each(function() {
                    if (!$(this).attr('name'))
                        return;
                    else
                        inline_attrs.push($(this).attr("name"));
                    var attr_name = $(this).attr("name").replace(new RegExp("[0-9]", "g"), "");
                    switch (this.type) {
                        case 'password':
                        case 'select-multiple':
                        case 'select-one':
                        case 'text':
                        case 'textarea':
                            inl_obj[attr_name] = $(this).val();
                            break;
                        case 'checkbox':
                        case 'radio':
                            inl_obj[attr_name] = this.checked;
                    }
                    if (inl_obj[attr_name] != "")
                        ignore = false;
                });
                if (!ignore)
                    raw_json["inlines"].push(inl_obj);
            });

            //remove inline attrs from raw_json...let them be inside raw_json.inlines only
            $.each(inline_attrs, function(index, attr) {
                delete raw_json[attr];
            });
            console.log(inline_attrs);


        },

        // fetch expandeds from the form as a list of objects
        parse_expanded: function(raw_json) {
            console.log("FORM: fetching expandeds");
            var element = this.expanded;
            var entity = this.element_entity_map[element];
            var desc = this.foreign_entities[entity][element]
            console.log("FORM:expande desc -" + JSON.stringify(desc));
            var placeholder = desc.expanded.placeholder;
            var all_inlines = $('#' + placeholder + ' tr');
            raw_json[element] = [];
            var that = this;
            var inline_attrs = [];
            $.each(all_inlines, function(index, inl) {
                var inl_obj = {};
                inl_obj["index"] = $(inl).attr("index");
                $(inl).find(':input').each(function(){
                    if(!$(this).attr('name'))
                        return;
                    inline_attrs.push($(this).attr("name"));
                    var attr_name = $(this).attr("name").replace(new RegExp("[0-9]", "g"), "");
    				switch(this.type) {
    					case 'password':
    					case 'select-multiple':
    					case 'select-one':
    					case 'text':
    					case 'textarea':
    						inl_obj[attr_name] = $(this).val();
    						break;
    					case 'checkbox':
    					case 'radio':
    						inl_obj[attr_name] = this.checked;
    				}
                });
                raw_json[element].push(inl_obj);
            });

            //remove inline attrs from raw_json...let them be inside raw_json.inlines only
            $.each(inline_attrs, function(index, attr) {
                delete raw_json[attr];
            });
            // console.log(inline_attrs);
        },

        // fetch bulks from the form as a list of objects
        parse_bulk: function(raw_json) {
            console.log("FORM: fetching bulks");
            var all_inlines = $('#bulk tr').not(".form_error");
            raw_json["bulk"] = [];
            var that = this;
            $.each(all_inlines, function(index, inl) {
                var inl_obj = {};
                inl_obj["index"] = $(inl).attr("index");
                $(inl).find(':input').each(function() {
                    if (!$(this).attr('name'))
                        return;
                    var attr_name = $(this).attr("name").replace(new RegExp("[0-9]", "g"), "");
                    switch (this.type) {
                        case 'password':
                        case 'select-multiple':
                        case 'select-one':
                        case 'text':
                        case 'textarea':
                            inl_obj[attr_name] = $(this).val();
                            break;
                        case 'checkbox':
                        case 'radio':
                            inl_obj[attr_name] = this.checked;
                    }
                    if (inl_obj[attr_name] != "")
                        ignore = false;
                });
                if (!ignore)
                    raw_json["bulk"].push(inl_obj);
            });
        },

        //preserve the background fields - not entered through form
        extend_edit_json: function(o_json) {
            o_json = $.extend(this.model_json, o_json);
            if (this.inline) {
                _.each(o_json.inlines, function(inl, index) {
                    var old_json = this.inl_models_dict[inl.id];
                    o_json.inlines[index] = $.extend(old_json, inl);
                }, this);
            }
            return o_json;
        },

        // clean the json before saving
        clean_json: function(form_json) {
            console.log("FORM: Before cleaning json - " + JSON.stringify(form_json))

            if (this.bulk) {
                $.each(form_json.bulk, function(index, obj) {
                    clean_object(obj);
                });
            } else {
                clean_object(form_json);
                if (this.inline) {
                    $.each(form_json.inlines, function(index, obj) {
                        clean_object(obj);
                    });
                }
            }

            function clean_object(obj) {
                for (member in obj) {
                    if (member == "")
                        delete obj[member];
                    else if (!obj[member]) {
                        obj[member] = null
                        if (this.$('[name=' + member + ']').is('select[multiple]')) {
                            obj[member] = [];
                        }
                    }
                    else if(typeof(obj[member])=="string"){
                        obj[member] = obj[member].trim();
                    }
                }
            }
            console.log("FORM: After cleaning json - " + JSON.stringify(form_json))

        },

        include_borrowed_attributes: function(o_json, fields) {
            _.each(o_json.bulk, function(bulk, index) {
                _.each(fields, function(field, index) {
                    bulk[field] = parseInt(this.$('[name=' + field + ']').val());
                }, this);
            }, this);
        },

        //initialize the Denormalize module to denormalize the form's objects
        denormalize_json: function(json) {
            var dfds = [];
            if (this.bulk) {
                _.each(json.bulk, function(bulk, index) {
                    var dfd = Denormalizer.denormalize(bulk, this.bulk.foreign_fields);
                    dfds.push(dfd);
                }, this);
            } else {
                var dfd = Denormalizer.denormalize(json, this.foreign_entities);
                dfds.push(dfd);
                if (this.inline) {
                    _.each(json.inlines, function(inline, index) {
                        var dfd = Denormalizer.denormalize(inline, this.inline.foreign_entities);
                        dfds.push(dfd);
                    }, this);
                }
            }
            return $.when.apply($, dfds);
        },

        //converts form into json object
        serialize_form: function() {
            var json = {};
            if (this.bulk) {
                this.parse_bulk(json);
                this.include_borrowed_attributes(json, this.bulk.borrow_fields);
            } else {
                json = Backbone.Syphon.serialize(this);
                if (this.expanded)
                    this.parse_expanded(json);
                if (this.inline)
                    this.parse_inlines(json);
            }
            return json;
        },


        save: function() {
            //clear old errors
            this.show_errors(null);
            //set state to loading
            this.set_submit_button_state('loading');
            //get a json object out of the form
            this.final_json = this.serialize_form();
            //clean json to be able to send to server
            this.clean_json(this.final_json);
            //denormalise the foreign elements in json
            var that = this;
            this.denormalize_json(this.final_json)
                .done(function() {
                    //preserve the background fields - not entered through form:
                    if (that.edit_case)
                        that.final_json = that.extend_edit_json(that.final_json);
                    /*form rendered, form filled by user, save clicked, savable json prepared,
                    this module's work is done for now, sending event*/
                    var ev_data = {
                        context: that,
                    };
                    that.trigger("save_clicked", ev_data);
                })
                .fail(function() {
                    console.log("Denormalising json failed!");
                });
        },

        button2_clicked: function() {
            var ev_data = {
                context: this,
            };
            this.trigger("button2_clicked", ev_data);
        }


    });

    // Our module now returns our view
    return ShowAddEditFormView;
});
