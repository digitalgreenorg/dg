// Responsible for preparing form - for both Add and Edit, converting form to json, cleaning json, denormalising json and then triggering "save_clicked" event.
// Supports 2 buttons - first button does the above mentioned tasks from converting form to json to triggering "save_clicked" event.
// seond button - sends "button2_clicked" directly. 
// Used by Upload.js and form_controller.js. Both listen to the save_clicked and button2_clicked events to process the json generated by form
define([
    'jquery',
    'underscore',
    'layoutmanager',
    'form_field_validator',
    'syphon',
    'views/notification',
    'indexeddb_backbone_config',
    'configs',
    'offline_utils',
    'denormalize',
    'models/user_model',
    'indexeddb-backbone',
    'chosen',
    'date_picker',
    'time_picker'
], function(jquery, underscore, layoutmanager, pass, pass, notifs_view, indexeddb, all_configs, Offline, Denormalizer, User) {


    var ShowAddEditFormView = Backbone.Layout.extend({

        events: {
            'click #button2': 'button2_clicked',
            // used in inline form
            'click #add_rows': 'append_new_inlines',
        },
        template: '#form_template',
        options_inner_template: _.template($('#options_template')
            .html()),

        //would be called when render is called       
        serialize: function() {
            // send the following info to template
            // already contains the names of the buttons
            var s_passed = this.options.serialize;
            var language = User.get('language');
            this.type_of_cocouser = User.get('type_of_cocouser');
            this.entity_config = all_configs[this.entity_name];
            // HTML for form 
            //s_passed["form_template"] = this.form_template;
            // whether its an inline form
            s_passed["inline"] = (this.inline) ? true : false;
            // name of the entity bieng added/edited
            s_passed["entity_name"] = this.entity_name;
            s_passed["language"] = language;
            s_passed["add_row"] = this.entity_config['labels_'+language]['add_row'];
            return s_passed;
        },

        
        // Identifies the action of this form - add/ edit_id/ edit_json  
//         Sets the result on the view object 
//         this.edit_case_id, this.edit_case_json, this.edit_case
        identify_form_action: function(params) {
            // There are two ways in which edit is true - when the ID is given, and the second is when a json is given(LIMIT: can be add too if json is missing id?).
            this.edit_case = false;
            this.edit_id = null;
            if (params.model_json) {
                // edit_case_upload
                this.edit_case_json = true; 
                this.model_json = params.model_json;
                this.edit_case = true;
                this.edit_id = this.model_json.id;
            } else if (params.model_id) {
                this.edit_case_id = true;
                this.edit_case = true;
                this.edit_id = params.model_id;
            }
        },

        
        // Refactor possible
//         Reads entity_config and sets basic properties on view object for easy access
        read_form_config: function(params) {
            var language = User.get("language");
            var cocousertype = User.get('type_of_cocouser')
            this.cocousertype = cocousertype
            this.entity_name = params.entity_name;
            this.entity_config = all_configs[this.entity_name];
            //default locations - 
            this.foreign_entities = this.entity_config.foreign_entities;
            this.inline = this.entity_config.inline;
            this.bulk = this.entity_config.bulk;
            this.labels = this.entity_config['labels_'+language]
            this.health_variable = all_configs.misc.variable_dict[Object.keys(all_configs.misc.variable_dict)[1]]
            this.agg_variable = all_configs.misc.variable_dict[Object.keys(all_configs.misc.variable_dict)[0]]
            
            if (this.edit_case) {
                this.form_template = _.template($('#' + this.entity_config.edit_template_name).html());
                if (this.entity_config.edit) {
                    this.foreign_entities = this.entity_config.edit.foreign_entities;
                    this.inline = this.entity_config.edit.inline;
                    this.bulk = this.entity_config.edit.bulk;
                }
            } else {
                this.form_template = _.template($('#' + this.entity_config.add_template_name).html());
                if (this.entity_config.add) {
                    this.foreign_entities = this.entity_config.add.foreign_entities;
                    this.inline = this.entity_config.add.inline;
                    this.bulk = this.entity_config.add.bulk;
                }
            }
        },

        // Relies on view object's context 
        // Gets foreign entities, create their offline collection to be fetched in afterRender
        // Sets up datastructures to setup in-form change events
        // Shamelessly polluting the view object
        setup_foreign_elements: function() {
            //stores the foreign entities' collections
            this.f_colls = []; 
            //stores the index of an entity to access its collection in f_colls            
            this.f_index = []; 
            //stores the dependency mapping between form elements
            this.source_dependents_map = {}; 
            //stores maping between filters and their dependent elements
            this.source_filter_dependent_map = {};
            //stores the mapping between foreign element and their entity
            this.element_entity_map = {}; 
            //stores whether a foreign element has been rendered
            this.foreign_elements_rendered = {}; 
            //stores the number of sources for a dependent element
            this.num_sources = {}; 
            //create a collection for each distinct entity, put them in this.f_colls, remem their index in f_colls using f_index
            for (f_entity in this.foreign_entities) {
                var f_collection = Offline.create_b_collection(f_entity, {
                    comparator: function(model) {
                        return model.get(all_configs[this.storeName].sort_field).toLowerCase();
                    }
                });
                this.f_index.push(f_entity);
                this.f_colls.push(f_collection);
                //create entity_map, dependency map, foreign_elements_rendered, for each foreign element
                for (var element in this.foreign_entities[f_entity]) {
                    //created mapping of element - entity
                    this.element_entity_map[element] = f_entity;
                    this.foreign_elements_rendered[element] = false;
                    // creating source - dependency mapping to be used for in-form events
                    var dependency = this.foreign_entities[f_entity][element]["dependency"];
                    var filter_dependency = this.foreign_entities[f_entity][element]["filter_dependency"];
                    if (dependency)
                        this.num_sources[element] = dependency.length;
                    else
                        this.num_sources[element] = 0;
                    if (dependency) {
                        var f_ens = this.foreign_entities;
                        var that = this;
                        $.each(dependency, function(index, dep) {
                            var source_elm = dep.source_form_element;
                            if (source_elm in that.source_dependents_map)
                                that.source_dependents_map[source_elm].push(element);
                            else {
                                that.source_dependents_map[source_elm] = [];
                                that.source_dependents_map[source_elm].push(element);
                            }
                        });
                        console.log("source_dependents_map = " + JSON.stringify(this.source_dependents_map));
                    }

                    if (filter_dependency) {
                        var f_ens = this.foreign_entities;
                        var that = this;
                        $.each(filter_dependency, function(index, dep) {
                            var source_elm = dep.source_form_element;
                            if (source_elm in that.source_filter_dependent_map)
                                that.source_filter_dependent_map[source_elm].push(element);
                            else {
                                that.source_filter_dependent_map[source_elm] = [];
                                that.source_filter_dependent_map[source_elm].push(element);
                            }
                        });
                        console.log("source_filter_dependent_map = " + JSON.stringify(this.source_filter_dependent_map)); 
                    }

                }
            }
        },

        /*
        params = {
            serialiaze:{
                //name of first button, not shown if ==""
                button1: "...",
                //name of sec button, not shown if ==""
                button2: "..."
            },
            //name of entity to be added/edited
            entity_name:,
            //id of model if edit case
            model_id:,
            //json of model to be shown in edit form - used when json!= json(model_id)
            model_json:,
        }
        */
        initialize: function(params) {
            console.log("ADD/EDIT: params to add/edit view: ");
            console.log(params);
            this.final_json = null;
            _.bindAll(this);

            //sets this.edit_case, and  this.edit_case_id, or this.edit_case_json
            this.identify_form_action(params);

            //read entity_config and sets main properties on view object for easy access
            this.read_form_config(params);

            //reads this.foreign_entities and setsup the collections, source_dependents_map
            this.setup_foreign_elements();
        },

        afterRender: function() {
            var that = this;
            
            //rendering labels
            this.render_labels();
            //no foreign element has been rendered yet so disabling all - they get enabled as and when they get rendered
            this.disable_foreign_elements();

            //start in-form change events
            this.start_change_events();

            //fetch all foreign collections and render them when all are fetched
            this.fetch_and_render_foreign_entities();

            //if edit case - fill form with the model
            if (this.edit_case)
                this.render_edit_model();

            //if inline case - render inlines
            if (this.inline)
                this.render_inlines();

            // call validator on the form
            this.initiate_form_field_validation();

            this.initiate_form_widgets();
        },

        render_labels: function(){
            $f_el = this.$("#form_template_render");
            $f_el.append(this.form_template(this.labels));
            var cocousertype = User.get('type_of_cocouser')
            var partner_name = User.get('partner_name');
            var partner_check = jQuery.inArray(partner_name, all_configs.misc.ethiopia_partners)
            if (partner_check < 0){
                $f_el.find("#is_modelfarmer").addClass('hidden');
            }
            // force hiding of upavan field
            _.each(all_configs.misc.element_to_be_hidden_for_upavan, function(val, key){
                $f_el.find(val).addClass('hidden')
            })
            //  for UPAVAN
            if (cocousertype == 4){
                //to change labels
                _.each(all_configs.misc.label_upavan_dict, function(value, key){
                    $f_el.find(key).text(value)
                })
                // to hide fields
                _.each(all_configs.misc.upavan_user_fields, function(element, index) {
                    $f_el.find(element).removeClass('hidden')
                })
            }else{
                _.each(all_configs.misc.upavan_user_fields, function(element, index) {
                    $f_el.find(element).addClass('hidden')
                })
                //to change labels
                _.each(all_configs.misc.label_dict, function(value, key){
                    $f_el.find(key).text(value)
                })
                
            }

        },
        
        //fetches all foreign collections and renders them when all are fetched
        fetch_and_render_foreign_entities: function() {
            var for_entities_fetch_dfds = []
            for (var i = 0; i < this.f_colls.length; i++) {
                console.log("fetching f coll");
                var f_dfd = this.f_colls[i].fetch();
                for_entities_fetch_dfds.push(f_dfd);
            }
            // wait till all foreign collections are fetched and then render the non-dependent foreign elements - the dependent foreign elements gets rendered through in-form events
            $.when.apply($, for_entities_fetch_dfds)
                .done(this.render_non_dep_for_elements)
                .fail(function() {
                    //TODO: handle error callback
                    alert("Atleast one foreign entity could not be fetched!");
                })
        },

        //fill non-dependent foreign elements - dependent gets filled on change events
        render_non_dep_for_elements: function() {
            console.log("Rendering non dependent f elements");
            _.each(this.element_entity_map, function(entity, element) {
                if (!this.foreign_entities[entity][element]["dependency"])
                    this.render_foreign_element(element, this.get_collection_of_element(element).toArray());
                    if (this.entity_config.entity_name == this.entity_config.field_change_entity_name && this.$el.find('#id_' + this.entity_config.fetch_element_that_manipulate).val() == this.agg_variable| this.$el.find('#id_' + this.entity_config.fetch_element_that_manipulate).val() == null){
                        if (cocousertype != 4){
                            // hide the headers and fields
                            _.each(this.entity_config.hide_dict, function(key, value) {
                                $(key).addClass('hidden')
                                $(value).addClass('hidden')
                            })
                            this.$el.find(this.entity_config.remove_attribute_field).removeAttr('required');
                        }
                     }else if(this.entity_config.entity_name == this.entity_config.field_change_entity_name && this.$el.find('#id_' + this.entity_config.fetch_element_that_manipulate).val() == this.health_variable){
                        if (cocousertype != 4){
                            _.each(this.entity_config.hide_dict, function(key, value) {
                                $(key).removeClass('hidden')
                                $(value).removeClass('hidden')
                            })
                        }

                     }else if (this.entity_config.entity_name == this.entity_config.field_change_entity_name && this.$el.find('#id_' + this.entity_config.fetch_element_that_manipulate).val() == this.agg_variable){
                         if (element == this.entity_config.fetch_element_that_manipulate && $("#id_"+this.entity_config.fetch_element_that_manipulate).val() == this.agg_variable){
                            if (this.edit_case && this.foreign_elements_rendered[element]){
                                this.$el.find(this.entity_config.remove_attribute_field).removeAttr('required');
                                if (cocousertype != 4){
                                    _.each(this.entity_config.hide_dict, function(key, value) {
                                        $(key).addClass('hidden')
                                        $(value).addClass('hidden')
                                    })
                                }
                            } 
                        }   
                    }
            }, this);

        },

        // fetch edit object and render it into form
        render_edit_model: function() {
            var that = this;
            // if this is edit_Case_json case (used by UPLOAD ) - we have the json
            if (this.edit_case_json) {
                // normalise json to put into form
                this.normalize_json(this.model_json);
                // put into form
                this.fill_form();
            } else if (this.edit_case_id) {
                // fetch edit object
                Offline.fetch_object(this.entity_config.entity_name, "id", this.edit_id)
                    .done(function(model) {
                        console.log("EDIT: edit model fetched");
                        that.model_json = model.toJSON();
                        // normalise json to put into form
                        that.normalize_json(that.model_json);
                        // fields to hide
                        if (that.entity_config.show_health_provider_present != that.model_json.parentcategory){
                            
                            that.$el.find("#"+that.entity_config.parent_element_label_to_hide).addClass('hidden');
                            that.$el.find("#id_"+that.entity_config.parent_element_to_hide).addClass('hidden');
                        }
                        // text to select 
                        if (that.entity_config.text_to_select_display_hack){
                             // for multiple fields
                            if (that.entity_config.text_to_select_display_hack_field_array){
                                _.each(that.entity_config.text_to_select_display_hack_field_array, function(element, index) {
                                    that.$el.find("#id_" + element + " option[value="+ that.model_json[element]+"]").attr('selected', 'selected')
                                    $("#id_" + element).change().trigger("chosen:updated");
                                })
                            }
                            // for single fields
                            if(that.entity_config.text_to_select_display_hack_field_id){
                                var text_to_select_display_var  = that.model_json[that.entity_config.text_to_select_display_hack_field_id]
                                that.$el.find("#id_" + that.entity_config.text_to_select_display_hack_field_id + " option[value="+ text_to_select_display_var +"]").attr('selected', 'selected')
                                $("#id_" + that.entity_config.text_to_select_display_hack_field_id).change().trigger("chosen:updated");
                            }
                        }
                        // put into form
                        that.fill_form();
                    })
                    .fail(function() {
                        // edit object could not be fetched from offline db
                        //TODO: error handling
                        console.log("ERROR: EDIT: Edit model could not be fetched!");
                        alert("ERROR: EDIT: Edit model could not be fetched!");
                    });
            }
        },

        //disable dropdowns of all foreign elements - they would be enabled as and when they get populated
        disable_foreign_elements: function() {
            for (f_entity in this.foreign_entities) {
                for (element in this.foreign_entities[f_entity]) {
                    if (!this.foreign_entities[f_entity][element].expanded) {
                        this.$('[name=' + element + ']').prop("disabled", true);
                    }
                }
            }
        },

        //render header, empty inlines if add case, fetch and render related inlines if edit case
        render_inlines: function() {
            var that = this;
            var temp = _.template($('#' + this.inline.header).html());
            $f_el = this.$('#inline_header');
            $f_el.append(temp(this.labels));
            if (that.cocousertype == 4){
                // force hiding of upavan field
                _.each(all_configs.misc.inline_var_to_be_hidden, function(val, key){
                    $f_el.find(key).addClass('hidden')
                    $f_el.find(val).addClass('hidden')
                })
                //to change labels
                _.each(all_configs.misc.inline_upavan_label_dict, function(value, key){
                    $f_el.find(key).text(value)
                })
            }else{
                _.each(all_configs.misc.inline_var_to_be_hidden, function(val, key){
                    $f_el.find(key).removeClass('hidden')
                    $f_el.find(val).removeClass('hidden')
                })
                //to change labels
                _.each(all_configs.misc.inline_label_dict, function(value, key){
                    $f_el.find(key).text(value)
                })
            }
            //if add case put in empty inlines
            if (!this.edit_case)
                this.append_new_inlines(this.inline.default_num_rows);
            else if (this.edit_case_id) {
                console.log("FORM:EDIT: Fteching inline collection");
                // fetch inline entity's whole collection! can be improved
                Offline.fetch_collection(this.inline.entity)
                    .done(function(collection) {
                        // id-json dictionary of inline models - later used to extend the modified inlines
                        that.inl_models_dict = {};
                        // filter inline collection to get only the ones related to the parent object
                        var inl_models = collection.filter(function(model) {
                            if (model.get(that.inline.joining_attribute.inline_attribute).id == that.edit_id) {
                                that.inl_models_dict[model.get("id")] = model.toJSON();
                                return true
                            }
                            return false;
                        });
                        console.log(inl_models);
                        // render the inlines into the form
                        that.fill_inlines(inl_models);
                    })
                    .fail(function() {
                        console.log("ERROR: EDIT: Inline collection could not be fetched!");
                    });
            }
            //not showing the inlines in case of edit_case_json
        },


        // fills the inline objects in their templates and puts them into form
        fill_inlines: function(model_array) {
            console.log("Filling inlines");
            var that = this;
            var inline_t = _.template($('#' + this.inline.template).html());

            $.each(model_array, function(index, model) {
                var tr = inline_t({
                    index: index
                });
                var filled_tr = that.fill_form_elements($(tr), model.toJSON());
                $(filled_tr).find(':input').removeClass("donotvalidate");
                that.$('#inline_body').append(filled_tr);
                $(filled_tr).on('change', that.switch_validation_for_inlines);
            });
        },

        // appends new empty inlines into form
        append_new_inlines: function(num_rows) {
            // compile the template of inline
            var inline_t = _.template($('#' + this.inline.template).html());
            if (typeof(num_rows) != "number")
                num_rows = this.inline.add_row;
            var start_index = get_index_to_start_from();
            // append the new inlines
            for (var i = start_index; i < start_index + num_rows; i++) {
                var tr = $(inline_t({
                    index: i
                }));
                this.$('#inline_body').append(tr);
                // switch validation on/off based on whether the inline is empty or not
                if (this.cocousertype == 4){
                    // force hiding of upavan field
                    _.each(all_configs.misc.inline_var_to_be_hidden, function(val, key){
                        this.$('#inline_body').find(key).addClass('hidden')
                       this.$('#inline_body').find(val).addClass('hidden')
                    })
                }else{
                    _.each(all_configs.misc.inline_var_to_be_hidden, function(val, key){
                        this.$('#inline_body').find(key).removeClass('hidden')
                        this.$('#inline_body').find(val).removeClass('hidden')
                    })
                }
                tr.on('change', this.switch_validation_for_inlines);
            }

            // get last index of already existing inlines
            function get_index_to_start_from() {
                var all_present_inlines = this.$('#inline_body tr').not(".form_error");
                if (!all_present_inlines.length)
                    return 0
                var max_index = $(_.last(all_present_inlines)).attr("index");
                return parseInt(max_index) + 1;
            }
        },

        // to prevent validation of empty inline rows
        switch_validation_for_inlines: function(ev) {
            //get the changed row
            var elem = ev.delegateTarget;
            var empty = true;
            $(elem).find(':input').each(function() {
                if ($(this).val())
                    empty = false;
            });
            if (!empty) {
                // if row is not emoty - turn on validation
                $(elem).find(':input').each(function() {
                    $(this).removeClass("donotvalidate");
                });
            } else {
                // if row is empty - turn off validation
                $(elem).find(':input').each(function() {
                    $(this).addClass("donotvalidate");
                });
            }
        },

        //takes a jquery object containgg form elements and a json. Fills all elements with the corrsponding value in json
        fill_form_elements: function(container, o_json) {
            container.attr("model_id", o_json.id);
            container.find(':input').each(function() {
                if (!$(this).attr('name'))
                    return;
                var attr_name = $(this).attr("name").replace(new RegExp("[0-9]", "g"), "");
                switch (this.type) {
                    case 'password':
                    case 'select-multiple':
                    case 'select-one':
                    case 'text':
                    case 'textarea':
                        $(this).val(o_json[attr_name]);
                        break;
                    case 'checkbox':
                    case 'radio':
                        this.checked = o_json[attr_name];
                }
            });
            return container;
        },

        // start listening to in-form events
        start_change_events: function() {
            for (element in this.source_dependents_map) {
                console.log("creating changeevent for - " + element);
                // put change-event listeners on source elements
                this.$('[name=' + element + ']').change(this.render_dep_for_elements);
            }
            for (element in this.source_filter_dependent_map) {
                console.log("creating changeevent for - " + element);
                // put change-event listeners on source elements
                this.$('[name=' + element + ']').change(this.render_dep_for_elements);
            }
        },

        // initiate the jquery validation plugin on the form
        initiate_form_field_validation: function() {
            var that = this;
            // pass the config defined in entity's config
            var validate_obj = $.extend(this.entity_config.form_field_validation, {
                "submitHandler": function() {
                    that.save();
                }
            });
            console.log()
            this.$('form')
                .validate(validate_obj);
        },

        // initiate the dropdown and date, time widgets
        initiate_form_widgets: function() {
            $(".chosen-select").chosen({
                'search_contains': true,
                'width': '100%'
            });


            var eDate = new Date();
            enddate = eDate.getFullYear() + "-" + (eDate.getMonth() + 1) + "-" + eDate.getDate();
            $(".date-picker")
                .datepicker({
                    format: 'yyyy-mm-dd',
                    startDate: '2009-01-01',
                    endDate: enddate,
                }).on('changeDate', function(ev) {
                    $(this).datepicker('hide');
                });

            $(".time-picker")
                .timepicker({
                    minuteStep: 1,
                    defaultTime: false,
                    showMeridian: false
                });
        },

        get_collection_of_element: function(element) {
            var entity = this.element_entity_map[element];
            var index = this.f_index.indexOf(entity);
            return this.f_colls[index];
        },

        get_sources_of_element: function(element) {
            var entity = this.element_entity_map[element];
            return this.foreign_entities[entity][element].dependency;
        },

        get_curr_value_of_element: function(element) {
            return $('[name=' + element + ']').val();
        },

        action_after_render_foreign_element: function(parent_element, dep_element){
            if (this.$el.find('#id_' + parent_element).val() == this.agg_variable && $("#id_"+ dep_element).val() == ''|$("#id_"+ dep_element) != "") {
                if (cocousertype != 4){
                    _.each(this.entity_config.hide_dict, function(key, value) {
                        console.log(key, value)
                        $(key).addClass('hidden')
                        $(value).addClass('hidden')
                    })
                    this.$el.find(this.entity_config.remove_attribute_field).removeAttr('required');
                }

            }
            if (this.$el.find('#id_' + parent_element).val() == this.health_variable && $("#id_"+ dep_element).val() == ''|$("#id_"+ dep_element) != "") {
                if (cocousertype != 4){
                    _.each(this.entity_config.hide_dict, function(key, value) {
                        $(key).removeClass('hidden')
                        $(value).removeClass('hidden')
                    })
                }else if(cocousertype == 4){
                    $("#id_health_provider_present").addClass('hidden')
                }
            }

        },

        // check if element value inside array is empty
        checkArrayElementisnotEmpty: function(arr, that){
           for(var i=0; i < arr.length; i++){
               if(that.$el.find(arr[i]).val() === "")   
                  return false;
           }
           return true;
        },

        // render dependent foreign elements - executes when a source element changes
        render_dep_for_elements: function(ev) {
            var source = $(ev.target).attr("name"); //source changed
            // var arr = this.entity_config.combination_display_field_with_value
            for (var key in this.entity_config.combination_display_dict) {
               var combination_display_field = key
               var arr = this.entity_config.combination_display_dict[key];
            }
            console.log("FILLING DEP ENTITIES OF -" + source);
            // Iterate over its dependents
            _.each(this.source_dependents_map[source], function(dep_el) {
                var filtered_models = this.filter_dep_for_element(dep_el);
                this.render_foreign_element(dep_el, filtered_models);
                // var arr = this.entity_config.combination_display_field_with_value
                var combination_field_to_display = combination_display_field
                if (!jQuery.isEmptyObject(arr) && this.checkArrayElementisnotEmpty(arr, this)){
                    this.$el.find(combination_field_to_display).prop("disabled", false);
                    this.$el.find(combination_field_to_display).trigger("chosen:updated");
                }
                if (!jQuery.isEmptyObject(arr) && !this.checkArrayElementisnotEmpty(arr, this)){
                   this.$el.find(combination_field_to_display).prop("disabled", true);
                   this.$el.find(combination_field_to_display).trigger("chosen:updated");
                }
                if (this.entity_config.parent_element_to_hide == dep_el && filtered_models.length == 0){
                    this.$el.find("#"+this.entity_config.dependent_element_div_hide).addClass('hidden');
                }
                if (this.entity_config.parent_element_to_hide == dep_el && filtered_models.length != 0){
                    this.$el.find("#"+this.entity_config.dependent_element_div_hide).removeClass('hidden');
                }
                this.action_after_render_foreign_element(this.entity_config.fetch_element_that_manipulate, dep_el)
            }, this);

            _.each(this.source_filter_dependent_map[source], function(dep_el) {
                var filtered_models = this.filter_dep_for_element(dep_el);
                this.render_foreign_element(dep_el, filtered_models);
            }, this);
        },

        // Fully Reset the dependent foreign element by looking at all its sources.
        filter_dep_for_element: function(element) {
            //get dependent element's entity's collection - to be filtered
            var dep_collection = this.get_collection_of_element(element);
            // get all sources of this element - to filter by
            var all_sources = this.get_sources_of_element(element);
            //model array to be finally inserted into dom
            var final_models = [];
            var that = this;

            if (!dep_collection.length)
                return [];

            $.each(all_sources, function(index, dep_desc) {
                var dep_attr = dep_desc.dep_attr;
                var source_form_element = dep_desc.source_form_element;
                var filtered_models = [];

                //LIMITS: source can't be an expanded right now, bcoz won't get its value
                var source_curr_value = that.get_curr_value_of_element(source_form_element);
                if (!source_curr_value)
                    return;
                else if (!(source_curr_value instanceof Array)) {
                    //if source is single select - convert its value to array -make it like a multiselect
                    var temp = source_curr_value;
                    source_curr_value = [];
                    source_curr_value.push((temp));
                }

                // many-to-many relation between source and dependent
                if (dep_collection.at(0).get(dep_desc.dep_attr) instanceof Array) {
                    filtered_models = dep_collection.filter(function(model) {
                        var exists = false;
                        //LIMITS: array assumed to contain objects - its an array so possibly other case not possible
                        $.each(model.get(dep_desc.dep_attr), function(index, object) {
                            if ($.inArray(String(object.id), source_curr_value) > -1)
                                exists = true;
                        });
                        return exists;
                    });
                } else {

                    filtered_models = dep_collection.filter(function(model) {
                        var d = dep_desc;
                        var exists = false;
                        var compare = null;
                        if (typeof model.get(dep_desc.dep_attr) == "object")
                            compare = model.get(dep_desc.dep_attr).id;
                        else
                            if (dep_desc.parent_attr){
                                compare = model.get(dep_desc.parent_attr)[dep_desc.dep_attr];
                            }else{
                                compare = model.get(dep_desc.dep_attr)
                            }

                        if (compare != null) {
                            if (dep_desc.src_attr && dep_desc.src_attr != "id") {
                                var s_collection = that.get_collection_of_element(source_form_element);
                                var s_model = s_collection.get(parseInt(source_curr_value[0]));
                                if (s_model.get(dep_desc.src_attr) instanceof Array) {
                                    //LIMITS: array assumed to contain objects - its an array so possibly other case not possible
                                    $.each(s_model.get(dep_desc.src_attr), function(index, src_compare) {
                                        if (compare == src_compare.id)
                                            exists = true;
                                    });
                                }
                                return exists;
                            } else {
                                if (!($.inArray(String(compare), source_curr_value) == -1))
                                    exists = true;
                                return exists;
                            }
                        }
                    });
                }
                final_models = final_models.concat(filtered_models);
            });
            return final_models;
        },

        // filter an array of modal based on a filter defined in configs
        filter_model_array: function(model_array, filter) {
            var filter_attr = filter.attr;
            var filter_value = filter.value;
            filtered = [];
            $.each(model_array, function(index, obj) {
                //LIMIT: assumed to be an object
                if (obj.get(filter_attr).id == filter_value) {
                    filtered.push(obj);
                }
            });
            return filtered;
        },

        // filter an array from attributes rather than array index itself
        filter_array_with_specific_parameters: function(array, filter_attr, filter_val) {
            filtered = [];
            $.each(array, function(index, obj) {
                
                if (obj.attributes[filter_attr] == filter_val) {
                    filtered.push(obj);
                }
            });
            return filtered;
        },

        filter_dependent_model_array: function(model_array, filter) {
            if(model_array.length == 0) return model_array;
            var that = this;
            var source_form_element = filter['source_form_element'];
            var source_curr_value = that.get_curr_value_of_element(source_form_element);
            var dep_attr = filter['dep_attr'];
            filtered = [];
            if (!source_curr_value)
                return;
            else if (!(source_curr_value instanceof Array)) {
                //if source is single select - convert its value to array -make it like a multiselect
                var temp = source_curr_value;
                source_curr_value = [];
                source_curr_value.push(temp);
            }
            if(model_array[0].get(dep_attr) instanceof Array) {
                model_array = model_array.filter(function(model) {
                    var exists = false;
                    //LIMITS: array assumed to contain objects - its an array so possibly other case not possible
                    $.each(model.get(filter.dep_attr), function(index, object) {
                        if ($.inArray(String(object.id), source_curr_value) > -1)
                            exists = true;
                    });
                    return exists;
                });
            } else {
                model_array = model_array.filter(function(model) {
                    var exists = false;
                    var compare = null;
                    if (typeof model.get(filter.dep_attr) == "object")
                        compare = model.get(filter.dep_attr).id;
                    else
                        compare = model.get(filter.dep_attr);

                    if (filter.src_attr && filter.src_attr != "id") {
                        var s_collection = that.get_collection_of_element(source_form_element);
                        var s_model = s_collection.get(parseInt(source_curr_value[0]));
                        if (s_model.get(filter.src_attr) instanceof Array) {
                            //LIMITS: array assumed to contain objects - its an array so possibly other case not possible
                            $.each(s_model.get(dep_desc.src_attr), function(index, src_compare) {
                                if (compare == src_compare.id)
                                    exists = true;
                            });
                        }
                        return exists;
                    } else {
                        if ($.inArray(String(compare), source_curr_value) > -1)
                            exists = true;
                        return exists;
                    }
                });
            }
            return model_array;
        },

        // renders a foreign element - dropdown or expanded templates - into the form
        render_foreign_element: function(element, model_array) {
            console.log("FILLING FOREIGN ENTITY - " + element);
            cocousertype = this.type_of_cocouser;
            inline_var = this.entity_config.inline_var;
            var that = this;
            this.num_sources[element]--;
            var f_entity_desc = this.foreign_entities[this.element_entity_map[element]][element];

            //if any defined, filter the model array before putting into dom
            if (f_entity_desc.filter)
                model_array = this.filter_model_array(model_array, f_entity_desc.filter);
                if (element == this.entity_config.fetch_element_that_manipulate && (cocousertype != 3 && cocousertype != 4)){
                   model_array = this.filter_array_with_specific_parameters(model_array, this.entity_config.fetch_key_element, cocousertype); 
                }
                
            //for filtering based on dependent fields
            if (f_entity_desc.filter_dependency)
                for(var i=0; i<f_entity_desc.filter_dependency.length; i ++){
                   model_array = this.filter_dependent_model_array(model_array, f_entity_desc.filter_dependency[i]);
                }
    
            if (f_entity_desc.expanded) {
                // get the expanded template
                var expanded_template = _.template($('#' + f_entity_desc.expanded.template).html());
                $f_el = this.$('#' + f_entity_desc.expanded.placeholder);
                $f_el.html('');
                //LIMIT: there can be only one expanded foreign element!
                this.expanded = element;

                //Its edit case and edit model is not yet rendered - so render it
                if (this.edit_case && !this.foreign_elements_rendered[element]) {
                    var id_field = "id"
                    if (f_entity_desc.id_field)
                        id_field = f_entity_desc.id_field;
                    var collection = this.get_collection_of_element(element);
                    var cat = [];
                    $.each(this.model_json[element], function(index, f_json) {
                        model = collection.get(f_json[id_field]);
                        if (!model)
                            return;
                        var t_json = model.toJSON();
                        t_json["index"] = index;
                        $.each(f_entity_desc.expanded.extra_fields, function(index, field) {
                            t_json[field] = f_json[field];
                        });
                        $f_el.append(expanded_template(t_json));
                        if (t_json.category && t_json.category.length >= 1){
                            _.each(t_json.category, function(iterable, idx){   
                                if (iterable.id != 'undefined'){
                                    $f_el.find("."+inline_var + index +  " option[value=" + iterable.id + "]").attr('selected', 'selected');
                                    // $("."+inline_var+index).trigger("chosen:updated");
                                }
                            })
                        }
                    });
                    if (this.num_sources[element] <= 0)
                        this.foreign_elements_rendered[element] = true;

                } else {
                    $.each(model_array, function(index, f_model) {
                        var t_json = f_model.toJSON();
                        t_json["index"] = index;

                        $f_el.append(expanded_template(t_json));
                        // Offline.fetch_collection("directbeneficiaries")
                        //     .done(function(collection) {
                        //         $.each(collection.models, function (i, item) { 
                        //             $f_el.find("."+inline_var + index).append($('<option>', {value: item.attributes.id, text: item.attributes.direct_beneficiaries_category}))
                        //             $("."+inline_var+index).trigger("chosen:updated");
                        //         })
                                
                        //     })
                        //     .fail(function() {
                        //         console.log("ERROR: EDIT: Inline collection could not be fetched!");
                        //     });
                    

                    });
                    
                }
                if (cocousertype == 4){
                    //hiding dropdown options
                    _.each(all_configs.misc.menu_options_to_hide, function(value, key){
                        $(key).addClass('hidden')
                        $(value).addClass('hidden')
                    })
                    //to change labels
                    _.each(all_configs.misc.inline_upavan_label_dict, function(value, key){
                        $(key).text(value)
                    })
                    // hiding inline fields
                    _.each(all_configs.misc.inline_var_to_be_hidden, function(value, key){
                        $(key).removeClass('hidden')
                        $(value).removeClass('hidden')
                    })
                }else{
                    //hiding dropdown options
                    _.each(all_configs.misc.menu_options_to_hide, function(value, key){
                        $(key).removeClass('hidden')
                        $(value).removeClass('hidden')
                    })
                    // hiding inline fields
                    _.each(all_configs.misc.inline_var_to_be_hidden, function(value, key){
                        $(key).addClass('hidden')
                        $(value).addClass('hidden')
                    })
                    //to change labels
                    _.each(all_configs.misc.inline_label_dict, function(value, key){
                        $(key).text(value)
                    })
                }

                this.initiate_form_widgets();
                $('.inline_table').show();


                // if (this.$el.find('#id_'+ this.entity_config.fetch_element_that_manipulate).val() == this.agg_variable){
                //     _.each(this.entity_config.headers_to_hide, function(element, index) {
                //         $(element).addClass('hidden');
                //     })
                //     _.each(this.entity_config.fields_to_hide, function(element, index) {
                //         $(element).addClass('hidden');
                //     })
                //     this.$el.find(this.entity_config.remove_attribute_field).removeAttr('required');
                // }


            } else {
                console.log("NOT EXPANDED");
                if (!this.edit_case && !this.foreign_elements_rendered[element]){
                    $("#id_" + this.entity_config.fetch_element_that_manipulate).on('change', function(){
                        if ($(that.entity_config.reset_element).val() != ''){
                            $('.search-choice-close').click();
                            $(that.entity_config.reset_element).trigger("chosen:updated");
                        }
                    })
                }
                if (this.edit_case && this.foreign_elements_rendered[element]){
                    $("#id_"+ this.entity_config.fetch_element_that_manipulate + "_chosen").on('click', function(){
                        $('.search-choice-close').click();
                        $(that.entity_config.reset_element).trigger("chosen:updated");

                    })
                }

                $f_el = this.$('#' + f_entity_desc.placeholder);
                if ($f_el.is('select[multiple]'))
                    $f_el.html('');
                else
                    $f_el.html(this.options_inner_template({
                        id: "",
                        name: "------------"
                    }));
                $.each(model_array, function (index, f_model) {
                    var f_json = f_model;
                    if (f_model instanceof Backbone.Model)
                        f_json = f_model.toJSON();
                    if (f_json[f_entity_desc.name_field_extra_info]) {
                        var extra_info_group_name = "";
                        var extra_info_person_id = "";
                        var extra_info_father_name = "";
                        if(f_json[f_entity_desc.name_field_father_name] != null){
                            extra_info_father_name = f_json[f_entity_desc.name_field_father_name]
                        }
                        if (f_json[f_entity_desc.name_field_extra_info][f_entity_desc.name_field_group_name] != null) {
                            extra_info_group_name = f_json[f_entity_desc.name_field_extra_info][f_entity_desc.name_field_group_name];
                        }
                        if (f_json[f_entity_desc.name_field_person_id] != null) {
                            extra_info_person_id = f_json[f_entity_desc.name_field_person_id]
                        }
                        $f_el.append(that.options_inner_template({
                            id: parseInt(f_json["id"]),
                            name: f_json[f_entity_desc.name_field] + (extra_info_father_name != "" ? ' (' + extra_info_father_name + ')' : "") + (extra_info_group_name != "" ? ' (' + extra_info_group_name + ')' : "") + (extra_info_person_id !="" ? ' (' + extra_info_person_id + ')' : "")
                        }));
                    }
                    else {
                        $f_el.append(that.options_inner_template({
                            id: parseInt(f_json["id"]),
                            name: f_json[f_entity_desc.name_field]
                        }));
                    }
                });
                $f_el.prop("disabled", false);
                $f_el.trigger("chosen:updated");

                //select the options selected in edit model
                if (this.edit_case && !this.foreign_elements_rendered[element]) {
                    if (element == this.entity_config.fetch_element_that_manipulate && isNaN(this.model_json[element])){
                        this.$('form [name=' + element + ']').val('2').change().trigger("chosen:updated");
                        $("#id_"+element+" option:not(:selected)").remove();
                        this.$('form [name=' + element + ']').find("#id_"+element+" option:not(:selected)").remove();
                        this.$('form [name=' + element + ']').trigger("chosen:updated");
                    }else{
                        this.$('form [name=' + element + ']').val(this.model_json[element]).change();
                        this.$('form [name=' + element + ']').trigger("chosen:updated");
                    }
                    
                    if (this.num_sources[element] <= 0)
                        this.foreign_elements_rendered[element] = true;
                }
            }
        },

        // normalises the json before putting into form
        normalize_json: function(d_json) {
            console.log("FORM: Before Normalised json = " + JSON.stringify(d_json));
            var f_entities = this.foreign_entities;
            for (member in f_entities) {
                for (element in f_entities[member]) {
                    if ((element in d_json) && !(f_entities[member][element].expanded)) {
                        if (d_json[element] instanceof Array) {
                            var el_array = [];
                            $.each(d_json[element], function(index, object) {
                                el_array.push(parseInt(object["id"]));
                            });
                            d_json[element] = el_array;
                        } else {
                            d_json[element] = parseInt(d_json[element]["id"]);
                        }
                    }
                }
            }
            console.log("FORM: Normalised json = " + JSON.stringify(d_json));
            return d_json;
        },

        // Using Backbone.Syphon library to put normalised json into form
        fill_form: function() {
            console.log("FORM: filling form with the model - " + JSON.stringify(this.model_json));
            Backbone.Syphon.deserialize(this, this.model_json);
        },

        // used to disable the save button while save is in progress
        set_submit_button_state: function(state) {
            if (state == "disabled")
                this.$(".action_button").attr("disabled", true);
            else
                this.$(".action_button").button(state);
        },

        //err format - {"mediator": {"__all__": ["Animator with this Name, Gender and Partner already exists."]}}
        // {"form_name": {"element name": [list of errors]}}
        show_errors: function(errors, disable_submit) {
            // used to clear form errors
            if (errors == null) {
                $('.form_error').remove();
                $('.error').removeClass("error");
                return;
            }

            this.set_submit_button_state('reset');
            if (disable_submit)
                this.set_submit_button_state('disabled');

            if (typeof(errors) !== "object")
                errors = $.parseJSON(errors);
            console.log("Showing this error");
            console.log(errors);
            try {
                _.each(errors, function(errors_obj, parent) {
                    var parent_el = this.$('[name=' + parent + ']');
                    $.each(errors_obj, function(error_el_name, error_list) {
                        var error_ul = null;
                        all_li = "<li>" + error_list.join("</li><li>") + "</li>";
                        error_ul = "<tr class='form_error'><td colspan='100%'><ul>" + all_li + "</ul></td></tr>";
                        if (error_el_name == "__all__") {
                            parent_el.before(error_ul); //insert error message
                            parent_el.addClass("error"); //highlight
                        } else {
                            var error_el = parent_el.find('[name=' + error_el_name + ']');
                            error_el
                                .parent('div')
                                .parent('div')
                                .addClass("error"); //highlight
                            error_el.parent().append(error_ul); // insert error message after the element
                        }
                    });
                }, this);
            } catch (err) {
                //if the error object has an unknown format - show it as it is on top of form
                var parent_el = this.$('[name=' + this.entity_name + ']');
                parent_el.before("<div class='form_error'>" + JSON.stringify(errors) + "</div>"); //insert error message
            }

        },

        // TODO: the following 3 methods can be combined into single generic one
        // fetch inline from the form as a list of objects
        parse_inlines: function(raw_json) {
            console.log("FORM: fetching inlines");
            var all_inlines = $('#inline_body tr').not(".form_error");
            raw_json["inlines"] = [];
            var that = this;
            var inline_attrs = [];
            $.each(all_inlines, function(index, inl) {
                var inl_obj = {};
                var ignore = true;
                inl_obj.index = $(inl).attr("index");
                if ($(inl).attr("model_id"))
                    inl_obj.id = parseInt($(inl).attr("model_id"));
                $(inl).find(':input').each(function() {
                    if (!$(this).attr('name'))
                        return;
                    else
                        inline_attrs.push($(this).attr("name"));
                    var attr_name = $(this).attr("name").replace(new RegExp("[0-9]", "g"), "");
                    switch (this.type) {
                        case 'password':
                        case 'select-multiple':
                        case 'select-one':
                        case 'text':
                        case 'textarea':
                            inl_obj[attr_name] = $(this).val();
                            break;
                        case 'checkbox':
                        case 'radio':
                            inl_obj[attr_name] = this.checked;
                    }
                    if (inl_obj[attr_name] != "")
                        ignore = false;
                });
                if (!ignore)
                    raw_json["inlines"].push(inl_obj);
            });

            //remove inline attrs from raw_json...let them be inside raw_json.inlines only
            $.each(inline_attrs, function(index, attr) {
                delete raw_json[attr];
            });
            console.log(inline_attrs);


        },


        // fetch expandeds from the form as a list of objects
        parse_expanded: function(raw_json) {
            console.log("FORM: fetching expandeds");
            var element = this.expanded;
            var entity = this.element_entity_map[element];
            var desc = this.foreign_entities[entity][element]
            var fetch_element = this.entity_config.fetch_element
            var fetch_element_key = this.entity_config.fetch_key_element
            var child_element = this.entity_config.fetch_child_element
            console.log("FORM:expande desc -" + JSON.stringify(desc));
            var placeholder = desc.expanded.placeholder;
            var all_inlines = $('#' + placeholder + ' tr');
            raw_json[element] = [];
            var that = this;
            var inline_attrs = [];
            $.each(all_inlines, function(index, inl) {
                var inl_obj = {};
                inl_obj["index"] = $(inl).attr("index");
                $(inl).find(':input').each(function(){
                    if(!$(this).attr('name'))
                        return;
                    inline_attrs.push($(this).attr("name"));
                    var attr_name = $(this).attr("name").replace(new RegExp("[0-9]", "g"), "");
    				switch(this.type) {
    					case 'password':
    					case 'select-multiple':
    					case 'select-one':
    					case 'text':
    					case 'textarea':
    						inl_obj[attr_name] = $(this).val();
    						break;
    					case 'checkbox':
    					case 'radio':
    						inl_obj[attr_name] = this.checked;
    				}
                });
                // checking category from inline and then converting inlines request ids to actual objects
                if (inl_obj.category && inl_obj.category.length >= 0){
                    var category = []
                    _.each(inl_obj.category, function(idx, iter){ 
                        Offline.fetch_object(child_element, fetch_element_key, parseInt(idx))
                            .done(function(model_var) {
                                category.push({'id': model_var.attributes.id, 'category': model_var.attributes.direct_beneficiaries_category})
                                inl_obj.category = category;
                            })
                            .fail(function() {
                                // edit object could not be fetched from offline db
                                //TODO: error handling
                                console.log("ERROR: EDIT: Edit model could not be fetched!");
                                alert("ERROR: EDIT:");
                            });
                    })
                
                    
                }
                raw_json[element].push(inl_obj);
                if (fetch_element != null){
                   // saving in fetch_element offline table
                   var category = []
                   Offline.fetch_object(fetch_element, fetch_element_key, parseInt(inl_obj.person_id))
                    .done(function(model) {
                        model.save({'age': inl_obj.age, 'category': inl_obj.category, 'gender': inl_obj.gender});
                    })
                    .fail(function() {
                        // edit object could not be fetched from offline db
                        //TODO: error handling
                        console.log("ERROR: EDIT: Edit model could not be fetched!");
                        alert("ERROR: EDIT: Edit model could not be fetched!");
                    }); 
                }
                
            });

            //remove inline attrs from raw_json...let them be inside raw_json.inlines only
            $.each(inline_attrs, function(index, attr) {
                delete raw_json[attr];
            });
            // console.log(inline_attrs);
        },

        // fetch bulks from the form as a list of objects
        parse_bulk: function(raw_json) {
            console.log("FORM: fetching bulks");
            var all_inlines = $('#bulk tr').not(".form_error");
            raw_json["bulk"] = [];
            var that = this;
            $.each(all_inlines, function(index, inl) {
                var inl_obj = {};
                inl_obj["index"] = $(inl).attr("index");
                $(inl).find(':input').each(function() {
                    if (!$(this).attr('name'))
                        return;
                    var attr_name = $(this).attr("name").replace(new RegExp("[0-9]", "g"), "");
                    switch (this.type) {
                        case 'password':
                        case 'select-multiple':
                        case 'select-one':
                        case 'text':
                        case 'textarea':
                            inl_obj[attr_name] = $(this).val();
                            break;
                        case 'checkbox':
                        case 'radio':
                            inl_obj[attr_name] = this.checked;
                    }
                    if (inl_obj[attr_name] != "")
                        ignore = false;
                });
                if (!ignore)
                    raw_json["bulk"].push(inl_obj);
            });
        },

        //preserve the background fields - not entered through form
        extend_edit_json: function(o_json) {
            o_json = $.extend(this.model_json, o_json);
            if (this.inline) {
                _.each(o_json.inlines, function(inl, index) {
                    var old_json = this.inl_models_dict[inl.id];
                    o_json.inlines[index] = $.extend(old_json, inl);
                }, this);
            }

            return o_json;
        },

        // clean the json before saving
        clean_json: function(form_json) {
            console.log("FORM: Before cleaning json - " + JSON.stringify(form_json))

            if (this.bulk) {
                $.each(form_json.bulk, function(index, obj) {
                    clean_object(obj);
                });
            } else {
                clean_object(form_json);
                if (this.inline) {
                    $.each(form_json.inlines, function(index, obj) {
                        clean_object(obj);
                    });
                }
            }

            function clean_object(obj) {
                for (member in obj) {
                    if (member == "")
                        delete obj[member];
                    else if (!obj[member]) {
                        obj[member] = null
                        if (this.$('[name=' + member + ']').is('select[multiple]')) {
                            obj[member] = [];
                        }
                    }
                    else if(typeof(obj[member])=="string"){
                        obj[member] = obj[member].trim();
                    }
                }
            }
            console.log("FORM: After cleaning json - " + JSON.stringify(form_json))

        },

        include_borrowed_attributes: function(o_json, fields) {
            _.each(o_json.bulk, function(bulk, index) {
                _.each(fields, function(field, index) {
                    bulk[field] = parseInt(this.$('[name=' + field + ']').val());
                }, this);
            }, this);
        },

        //initialize the Denormalize module to denormalize the form's objects
        denormalize_json: function(json) {
            var dfds = [];
            if (this.bulk) {
                _.each(json.bulk, function(bulk, index) {
                    var dfd = Denormalizer.denormalize(bulk, this.bulk.foreign_fields);
                    dfds.push(dfd);
                }, this);
            } else {
                var dfd = Denormalizer.denormalize(json, this.foreign_entities);
                dfds.push(dfd);
                if (this.inline) {
                    _.each(json.inlines, function(inline, index) {
                        var dfd = Denormalizer.denormalize(inline, this.inline.foreign_entities);
                        dfds.push(dfd);
                    }, this);
                }
            }
            return $.when.apply($, dfds);
        },

        //converts form into json object
        serialize_form: function() {
            var json = {};
            if (this.bulk) {
                this.parse_bulk(json);
                this.include_borrowed_attributes(json, this.bulk.borrow_fields);
            } else {
                json = Backbone.Syphon.serialize(this);
                if (this.expanded)
                    this.parse_expanded(json);
                if (this.inline)
                    this.parse_inlines(json);
            }
            return json;
        },


        save: function() {
            //clear old errors
            this.show_errors(null);
            //set state to loading
            this.set_submit_button_state('loading');
            //get a json object out of the form
            this.final_json = this.serialize_form();
            //clean json to be able to send to server
            this.clean_json(this.final_json);
            //denormalise the foreign elements in json
            var that = this;
            this.denormalize_json(this.final_json)
                .done(function() {
                    //preserve the background fields - not entered through form:
                    if (that.edit_case)
                        that.final_json = that.extend_edit_json(that.final_json);
                    /*form rendered, form filled by user, save clicked, savable json prepared,
                    this module's work is done for now, sending event*/
                    var ev_data = {
                        context: that,
                    };
                    that.trigger("save_clicked", ev_data);
                })
                .fail(function() {
                    console.log("Denormalising json failed!");
                });
        },

        button2_clicked: function() {
            var ev_data = {
                context: this,
            };
            this.trigger("button2_clicked", ev_data);
        }


    });

    // Our module now returns our view
    return ShowAddEditFormView;
});
